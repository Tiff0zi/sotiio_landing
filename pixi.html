<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Sotiio Pixi Hex Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body {
      margin:0;
      height:100%;
      overflow:hidden;
      background:#1e1e1e;
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
    }

    
    /* ───── ПАЛИТРА СЛОЁВ ───── */
    #palette-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10;

      padding: 10px 12px 18px;
      width: 170px;
      height: 190px;

      background: rgba(20, 20, 20, 0.92);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(14px);

      transition: all 0.25s ease;
    }

    /* Свернутое состояние — аккуратный чип с центральным цветом */
    #palette-panel.collapsed {
      height: auto;
      width: auto;
      padding: 6px 10px 10px;
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
    }

    #palette-panel.collapsed .palette-hexagon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: auto;
      height: auto;
    }

    #palette-panel.collapsed .palette-center {
      position: static;
      transform: none;
      width: 26px;
      height: 26px;
      margin: 0;
    }

    #palette-panel.collapsed .palette-center input {
      border-radius: 999px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }

    #palette-panel.collapsed .palette-sector,
    #palette-panel.collapsed .palette-placeholder {
      opacity: 0;
      pointer-events: none;
      width: 0;
      height: 0;
      margin: 0;
    }

    .palette-hexagon {
      position: relative;
      width: 100%;
      height: 100%;
      transition: all 0.3s ease;

      display: grid;
      grid-template-columns: repeat(3, 40px);
      grid-template-rows: repeat(3, 40px);
      gap: 6px;
      align-items: center;
      justify-items: center;
    }

    .palette-center {
      position: static;
      grid-row: 2;
      grid-column: 2;
      width: 40px;
      height: 40px;
      z-index: 3;
      transition: all 0.2s ease;
    }

    .palette-center input {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .palette-center input:hover {
      transform: scale(1.06);
      box-shadow: 0 6px 16px rgba(0,0,0,0.55);
    }

    .palette-sector {
      position: static;
      width: 36px;
      height: 36px;
      z-index: 2;
    }

    .palette-sector input {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.35);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .palette-sector input:hover {
      transform: scale(1.1);
      box-shadow: 0 5px 14px rgba(0,0,0,0.5);
    }

    /* 3×3 сетка:
       1 2 3
       8 0 4
       7 6 5
       2 и 6 — скрытые плейсхолдеры
    */

    .palette-sector[data-sector="1"] { grid-row: 1; grid-column: 1; } /* ↖ */
    .palette-sector[data-sector="2"] { grid-row: 1; grid-column: 3; } /* ↗ */
    .palette-sector[data-sector="3"] { grid-row: 2; grid-column: 3; } /* → */
    .palette-sector[data-sector="4"] { grid-row: 3; grid-column: 3; } /* ↘ */
    .palette-sector[data-sector="5"] { grid-row: 3; grid-column: 1; } /* ↙ */
    .palette-sector[data-sector="6"] { grid-row: 2; grid-column: 1; } /* ← */

    .palette-placeholder {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      opacity: 0;          /* «квадрат есть, но невидимый» */
      pointer-events: none;
    }

    .palette-placeholder[data-pos="2"] { grid-row: 1; grid-column: 2; }
    .palette-placeholder[data-pos="6"] { grid-row: 3; grid-column: 2; }

    .palette-toggle {
      position: absolute;
      bottom: -26px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20, 20, 20, 0.95);
      color: #bbb;
      border: none;
      border-radius: 12px;
      padding: 4px 12px;
      font-size: 10px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }

    .palette-toggle:hover {
      background: rgba(40, 40, 40, 0.98);
      color: #fff;
    }

    #loading-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, #333 0, #1e1e1e 55%, #050505 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 16px;
      color: #f5f5f5;
      font-size: 14px;
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #loading-overlay.visible {
      opacity: 1;
      pointer-events: all;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.15);
      border-top-color: #f97316;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loading-text {
      max-width: 280px;
      text-align: center;
      line-height: 1.4;
      color: #ddd;
    }

    #debug-panel {
      position: fixed;
      left: 20px;
      bottom: 20px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.6);
      color: #ccc;
      font-size: 11px;
      border-radius: 8px;
      z-index: 20;
      max-width: 320px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <div id="palette-panel" class="collapsed">
    <div class="palette-hexagon">
      <!-- 1 (↖) -->
      <div class="palette-sector" data-sector="1">
        <input class="palette-color" type="color" data-sector="1" title="L2-1 ↖" />
      </div>

      <!-- 2 — пустой, невидимый квадрат -->
      <div class="palette-placeholder" data-pos="2"></div>

      <!-- 3 (↗) -->
      <div class="palette-sector" data-sector="2">
        <input class="palette-color" type="color" data-sector="2" title="L2-2 ↗" />
      </div>

      <!-- 8 (←) -->
      <div class="palette-sector" data-sector="6">
        <input class="palette-color" type="color" data-sector="6" title="L2-6 ←" />
      </div>

      <!-- 0 — центр -->
      <div class="palette-center">
        <input class="palette-color" type="color" data-sector="0" title="Center L1" />
      </div>

      <!-- 4 (→) -->
      <div class="palette-sector" data-sector="3">
        <input class="palette-color" type="color" data-sector="3" title="L2-3 →" />
      </div>

      <!-- 7 (↙) -->
      <div class="palette-sector" data-sector="5">
        <input class="palette-color" type="color" data-sector="5" title="L2-5 ↙" />
      </div>

      <!-- 6 — пустой, невидимый квадрат -->
      <div class="palette-placeholder" data-pos="6"></div>

      <!-- 5 (↘) -->
      <div class="palette-sector" data-sector="4">
        <input class="palette-color" type="color" data-sector="4" title="L2-4 ↘" />
      </div>
    </div>

    <button class="palette-toggle">Палитра</button>
  </div>

  <div id="loading-overlay" class="visible">
    <div class="spinner"></div>
    <div id="loading-text">Загружаем карту…</div>
  </div>

  <div id="debug-panel"></div>

  <script src="/PixiJS/pixi.min.js"></script>

  <script>
  (async () => {
    if (!window.PIXI) {
      console.error('PIXI не найден');
      return;
    }

    const DPR = window.devicePixelRatio || 1;
    const app = new PIXI.Application();
    await app.init({
      width: 1,
      height: 1,
      background: '#1e1e1e',
      antialias: true,
      resolution: DPR,
      autoDensity: true
    });
    document.body.appendChild(app.canvas);

    PIXI.settings.ROUND_PIXELS = true;


    const container = new PIXI.Container();
    app.stage.addChild(container);

    let lastCells = null;
    let currentMapId = null;

    function resizeApp() {
      const w = document.documentElement.clientWidth || window.innerWidth || 800;
      const h = document.documentElement.clientHeight || window.innerHeight || 600;

      app.renderer.resize(w, h);
      container.x = w / 2;
      container.y = h / 2;
    }

    window.addEventListener('resize', resizeApp);
    resizeApp();

    const palettePanel = document.getElementById('palette-panel');
    const paletteToggle = palettePanel.querySelector('.palette-toggle');
    const paletteInputs = palettePanel.querySelectorAll('.palette-color');
    let paletteCollapsed = true;

    paletteToggle.addEventListener('click', (e) => {
      e.stopPropagation();
      paletteCollapsed = !paletteCollapsed;
      if (paletteCollapsed) {
        palettePanel.classList.add('collapsed');
      } else {
        palettePanel.classList.remove('collapsed');
      }
    });

    palettePanel.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    document.addEventListener('click', () => {
      if (!paletteCollapsed) {
        paletteCollapsed = true;
        palettePanel.classList.add('collapsed');
      }
    });

    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingText = document.getElementById('loading-text');
    const debugPanel = document.getElementById('debug-panel');

    function setLoading(visible, message = '') {
      if (visible) {
        loadingOverlay.classList.add('visible');
        loadingText.textContent = message || 'Загружаем карту…';
      } else {
        loadingOverlay.classList.remove('visible');
      }
    }

    function setDebug(text) {
      debugPanel.textContent = text;
    }

    function axialToPixel(q, r, size) {
      const x = size * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
      const y = size * (3 / 2 * r);
      return { x, y };
    }

    function createHexagon(size, fillColor, lineColor) {
      const g = new PIXI.Graphics();
      g.lineStyle(1, lineColor, 1);
      g.beginFill(fillColor, 1);

      const angle = Math.PI / 3;
      for (let i = 0; i < 6; i++) {
        const x = size * Math.cos(angle * i);
        const y = size * Math.sin(angle * i);
        if (i === 0) {
          g.moveTo(x, y);
        } else {
          g.lineTo(x, y);
        }
      }
      g.closePath();
      g.endFill();
      return g;
    }

    function wrapLabel(text) {
      if (!text) return '';

      const MAX_CHARS_SINGLE = 9;
      const MAX_LINES = 4;
      const MAX_WORDS_PER_LINE = 1;
      const MAX_LINE_LENGTH_MULTI = 10;

      const words = text.split(/\s+/).filter(Boolean);

      if (words.length === 1 && words[0].length > MAX_CHARS_SINGLE) {
        let w = words[0].slice(0, MAX_CHARS_SINGLE - 1) + '…';
        return w;
      }

      const lines = [];
      let currentLine = '';

      for (let i = 0; i < words.length; i++) {
        const word = words[i];

        if (lines.length >= MAX_LINES) break;

        if (MAX_WORDS_PER_LINE === 1) {
          lines.push(word);
          continue;
        }

        if (!currentLine) {
          currentLine = word;
          continue;
        }

        const testLine = currentLine + ' ' + word;
        if (testLine.length <= MAX_LINE_LENGTH_MULTI) {
          currentLine = testLine;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }

      if (currentLine && lines.length < MAX_LINES) {
        lines.push(currentLine);
      }

      return lines.slice(0, MAX_LINES).join('\n');
    }

    const HEX_SIZE = 40;
    const hexCells = [];

    function drawHexCell(q, r, labelText, fillColor) {
      const { x, y } = axialToPixel(q, r, HEX_SIZE);

      const graphics = createHexagon(HEX_SIZE, fillColor, 0x444444);
      graphics.x = x;
      graphics.y = y;
      graphics.interactive = true;
      graphics.cursor = 'pointer';

      container.addChild(graphics);

      const wrapped = wrapLabel(labelText);
      const text = new PIXI.Text({
        text: wrapped,
        style: {
          fill: 0xffffff,
          fontSize: 11,
          fontFamily: 'system-ui, Arial',
          fontWeight: '500',
          align: 'center'
        }
      });
      text.resolution = DPR;
      text.anchor.set(0.5);
      text.x = x;
      text.y = y;
      container.addChild(text);

      return {
        graphics,
        text,
        q,
        r,
        selected: false,
        data: null
      };
    }

    function drawHexMap(nodes) {
      container.removeChildren();
      hexCells.length = 0;

      nodes.forEach((node) => {
        const { q, r, label, fillColor } = node;
        const cell = drawHexCell(q, r, label, fillColor);
        cell.data = node;
        hexCells.push(cell);
      });

      container.x = app.renderer.width / 2;
      container.y = app.renderer.height / 2;
    }

    function findCellByNodeId(nodeId) {
      return hexCells.find(c => c.data && c.data.node_id === nodeId);
    }

    function updatePaletteInputs(colorsBySector) {
      paletteInputs.forEach(input => {
        const sector = input.dataset.sector;
        if (sector in colorsBySector) {
          input.value = colorsBySector[sector];
        }
      });
    }

    paletteInputs.forEach(input => {
      input.addEventListener('input', () => {
        if (!lastCells) return;

        const sector = input.dataset.sector;
        const colorValue = input.value;
        const colorNumber = parseInt(colorValue.replace('#', ''), 16);

        lastCells.forEach(cell => {
          if (!cell.data) return;
          if (String(cell.data.sector) === String(sector)) {
            cell.graphics.tint = colorNumber;
          }
        });
      });
    });

    let isPanning = false;
    let lastPan = { x: 0, y: 0 };

    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;
    app.stage.on('pointerdown', (e) => {
      isPanning = true;
      lastPan.x = e.global.x;
      lastPan.y = e.global.y;
      app.stage.cursor = 'grabbing';
    });

    app.stage.on('pointermove', (e) => {
      if (!isPanning) return;
      const dx = e.global.x - lastPan.x;
      const dy = e.global.y - lastPan.y;
      lastPan.x = e.global.x;
      lastPan.y = e.global.y;
      container.x += dx;
      container.y += dy;
    });

    app.stage.on('pointerup', () => {
      isPanning = false;
      app.stage.cursor = 'default';
    });

    app.stage.on('pointerupoutside', () => {
      isPanning = false;
      app.stage.cursor = 'default';
    });

    window.addEventListener('wheel', (e) => {
      const scaleFactor = 1.05;
      const oldScale = container.scale.x;
      const mousePos = { x: e.clientX, y: e.clientY };
      const worldPos = {
        x: (mousePos.x - container.x) / oldScale,
        y: (mousePos.y - container.y) / oldScale
      };

      if (e.deltaY < 0) {
        container.scale.x *= scaleFactor;
        container.scale.y *= scaleFactor;
      } else {
        container.scale.x /= scaleFactor;
        container.scale.y /= scaleFactor;
      }

      const newScale = container.scale.x;
      container.x = mousePos.x - worldPos.x * newScale;
      container.y = mousePos.y - worldPos.y * newScale;
    }, { passive: true });

    async function fetchMapData() {
      const urlParams = new URLSearchParams(window.location.search);
      const mapId = urlParams.get('map_id');

      if (!mapId) {
        setDebug('map_id не указан в query string');
        setLoading(false, '');
        return null;
      }

      currentMapId = mapId;
      setDebug(`map_id: ${mapId}`);

      try {
        setLoading(true, 'Запрашиваем карту…');
        const resp = await fetch(`/webhook/map?map_id=${encodeURIComponent(mapId)}`);
        if (!resp.ok) {
          setDebug(`Ошибка загрузки: ${resp.status} ${resp.statusText}`);
          setLoading(false, '');
          return null;
        }
        const json = await resp.json();

        if (!json || !Array.isArray(json.nodes)) {
          setDebug('Некорректный формат ответа: нет nodes');
          setLoading(false, '');
          return null;
        }

        setLoading(false, '');
        return json;
      } catch (err) {
        console.error(err);
        setDebug('Ошибка сети при загрузке карты');
        setLoading(false, '');
        return null;
      }
    }

    async function initMap() {
      const mapData = await fetchMapData();
      if (!mapData) return;

      const nodes = mapData.nodes.map(n => ({
        q: n.q,
        r: n.r,
        label: n.label,
        fillColor: parseInt((n.fillColor || '0x555555').toString().replace('#','').replace('0x',''), 16),
        node_id: n.node_id,
        sector: n.sector ?? 0
      }));

      lastCells = nodes;

      const colorsBySector = mapData.colorsBySector || {
        0: '#ff9800',
        1: '#4caf50',
        2: '#2196f3',
        3: '#9c27b0',
        4: '#f44336',
        5: '#ffeb3b',
        6: '#607d8b'
      };
      updatePaletteInputs(colorsBySector);

      drawHexMap(nodes);
    }

    await initMap();

  })();
  </script>
</body>
</html>
