<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>jsMind — webhook wait mode</title>
  <!-- jsMind (CDN). При желании замените на локальные пути к вашей сборке. -->
  <script src="https://unpkg.com/jsmind@0.8.6/es6/jsmind.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/jsmind@0.8.6/style/jsmind.css"/>
  <style>
    html, body { height: 100%; margin: 0; }
    #jsmind_container { position: absolute; inset: 0; }
    /* Лоадер поверх всей страницы */
    #loader {
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center;
      background: rgba(255,255,255,.6); z-index: 10000;
      font-weight: 600; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif;
    }
  </style>
</head>
<body>
  <div id="jsmind_container"></div>
  <div id="loader">Ждём ответ от вебхука…</div>

  <script>
    // ────────────────────────────
    // ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ UI
    // ────────────────────────────
    function showLoader(msg='Загружаем карту…'){
      const el = document.getElementById('loader');
      if (el) { el.textContent = msg; el.style.display = 'flex'; }
    }
    function hideLoader(){
      const el = document.getElementById('loader');
      if (el) el.style.display = 'none';
    }

    // Лёгкая маркировка уровней по node_id (опционально)
    function tagLevels(){
      try {
        const all = document.querySelectorAll('#jsmind_container jmnode');
        all.forEach(n => {
          const id = n.getAttribute('nodeid') || '';
          if (/^L1-/.test(id)) n.classList.add('lvl-1');
          else if (/^L2-/.test(id)) n.classList.add('lvl-2');
          else if (/^L3-/.test(id)) n.classList.add('lvl-3');
          else if (/^L4-/.test(id)) n.classList.add('lvl-4');
        });
      } catch(e) { /* no-op */ }
    }

    // ────────────────────────────
    // ПОЛЛИНГ СТАТУСА (для 202 Accepted)
    // ────────────────────────────
    async function pollUntilReady(url, {timeout=60000, interval=1500} = {}){
      const start = Date.now();
      while (true) {
        const r = await fetch(url, { cache: 'no-store' });
        const ct = r.headers.get('content-type') || '';
        if (r.ok && ct.includes('application/json')) {
          const j = await r.json();
          // Считаем готовым, если пришёл jsMind или флаг ready
          if (j?.format === 'node_tree' || j?.data || j?.ready) return j;
        }
        if (Date.now() - start > timeout) throw new Error('Timeout ожидания результата вебхука');
        await new Promise(res => setTimeout(res, interval));
      }
    }

    // ────────────────────────────
    // ЗАПРОС К ВЕБХУКУ С ОЖИДАНИЕМ
    // ────────────────────────────
    async function fetchMindFromWebhook(webhookUrl, payload, {timeout=60000, expect='auto'} = {}){
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), timeout);
      try{
        // Шаг 1: пробуем синхронный ответ
        const res = await fetch(webhookUrl, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(payload ?? {}),
          signal: controller.signal
        });

        // Если оркестратор отвечает 202 и даёт URL для поллинга — ждём
        if (res.status === 202) {
          const pollUrl = res.headers.get('Location') || res.headers.get('status_url');
          if (!pollUrl) throw new Error('202 Accepted без Location/status_url');
          const j = await pollUntilReady(pollUrl, {timeout});
          return j;
        }

        // Иначе читаем JSON сразу
        const data = await res.json();

        // Если это уже jsMind (format:"node_tree") — возвращаем как есть
        if (expect === 'jm' || (expect === 'auto' && data?.format === 'node_tree' && data?.data)) {
          return data;
        }

        // Иначе конвертируем через ваш локальный эндпойнт
        const conv = await fetch('/json_2_jm', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(data)
        });
        return await conv.json();
      } finally {
        clearTimeout(t);
      }
    }

    // ────────────────────────────
    // ИНИЦИАЛИЗАЦИЯ jsMind
    // ────────────────────────────
    const jm = new jsMind({
      container: 'jsmind_container',
      editable: false,
      theme: 'primary'
    });

    // ────────────────────────────
    // ОСНОВНОЙ ПОТОК
    // ────────────────────────────
    async function main(){
      const qs = new URLSearchParams(location.search);
      const task_id = qs.get('task');
      const filename = qs.get('name');

      const webhook = qs.get('webhook');             // напр.: https://n8n.sotiio.com/webhook/jm
      const timeout = +(qs.get('timeout') || 60000); // мс

      if (webhook) {
        showLoader('Ждём ответ от вебхука…');
        const payload = {
          task_id,
          filename,
          map_id: qs.get('map_id') || undefined
        };
        try{
          const mind = await fetchMindFromWebhook(webhook, payload, {timeout, expect:'auto'});
          jm.show(mind);
          jm.collapse_all();
          const root = jm.get_root(); if (root) jm.expand_node(root.id);
          setTimeout(() => { tagLevels(); jm.resize(); hideLoader(); }, 100);
          window.addEventListener('resize', ()=> jm.resize());
        }catch(e){
          hideLoader();
          alert('Ошибка загрузки карты через вебхук: ' + (e.message || e));
        }
        return; // выходим — обычный путь не нужен
      }

      // === Fallback: старый поток скачивания + локальный конвертер ===
      try{
        showLoader('Загружаем карту…');
        const url = `/download_files_pyrus?task_id=${encodeURIComponent(task_id||'')}&filename=${encodeURIComponent(filename||'')}&match_mode=exact&versions=latest`;
        const res = await fetch(url);
        const raw = await res.json();
        const conv = await fetch('/json_2_jm', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(raw)
        });
        const mind = await conv.json();
        jm.show(mind);
        jm.collapse_all();
        const root = jm.get_root(); if (root) jm.expand_node(root.id);
        setTimeout(() => { tagLevels(); jm.resize(); hideLoader(); }, 100);
        window.addEventListener('resize', ()=> jm.resize());
      }catch(err){
        hideLoader();
        alert('Ошибка загрузки карты: ' + (err.message || err));
      }
    }

    main();
  </script>
</body>
</html>
