<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Pixi Hex Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#202020; overflow:hidden; }
    #app { width:100vw; height:100vh; }
    .msg { position:fixed; left:10px; top:10px; color:#fff; font:14px/1.4 system-ui, sans-serif; }
    .err { color:#ff6b6b; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="msg" id="msg">Init‚Ä¶</div>

  <!-- –õ–æ–∫–∞–ª—å–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ -->
  <script src="./PixiJS/pixi.min.js?v=1"></script>
  <script src="./PixiJS/honeycomb-grid.umd.js?v=1"></script>

  <script>
  (async function () {
    const $msg = (t, err=false)=>{ const el=document.getElementById('msg'); el.textContent=t; el.className='msg'+(err?' err':''); };

    try {
      if (!window.PIXI) { $msg('PIXI –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è (–ø—Ä–æ–≤–µ—Ä—å –ø—É—Ç—å /PixiJS/pixi.min.js)', true); return; }
      if (!window.Honeycomb) { $msg('Honeycomb –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è (–ø—Ä–æ–≤–µ—Ä—å /PixiJS/honeycomb-grid.umd.js)', true); return; }

      // 1) –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Pixi v8
      const app = new PIXI.Application();
      await app.init({ resizeTo: window, background: '#202020', antialias: true });
      document.getElementById('app').appendChild(app.canvas);

      // 2) –°–∞–º–æ–ø—Ä–æ–≤–µ—Ä–∫–∞: –Ω–∞—Ä–∏—Å—É–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ (–µ—Å–ª–∏ —Ç—ã –≤–∏–¥–∏—à—å –µ–≥–æ ‚Äî Pixi —Ä–∞–±–æ—Ç–∞–µ—Ç)
      const test = new PIXI.Graphics();
      test.rect(20, 20, 120, 60).fill({ color: 0x3b82f6, alpha: 0.9 });
      app.stage.addChild(test);

      // 3) –¢–µ–ø–µ—Ä—å —Ä–∏—Å—É–µ–º –≥–µ–∫—Å—ã (pointy-top) —á–µ—Ä–µ–∑ honeycomb
      const Hex = Honeycomb.extendHex({ size: 40, orientation: 'pointy' });
      const Grid = Honeycomb.defineGrid(Hex);
      const hexes = Grid.rectangle({ width: 6, height: 6 });

      // –ü—Ä–µ–¥—Ä–∞—Å—á—ë—Ç –≤–µ—Ä—à–∏–Ω –æ–¥–Ω–æ–≥–æ –≥–µ–∫—Å–∞ (–ª–æ–∫–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)
      const cornerPoints = Hex().corners(); // [{x,y}...]
      const flatPoints = cornerPoints.flatMap(p => [p.x, p.y]); // –¥–ª—è poly()

      for (const hex of hexes) {
        const { x, y } = hex.toPoint(); // axial -> pixel (x,y)

        const g = new PIXI.Graphics();
        // –í Pixi v8 –∏—Å–ø–æ–ª—å–∑—É–µ–º poly() + fill()/stroke()
        g.poly(flatPoints, true);
        g.fill({ color: 0x88cc88, alpha: 0.6 });
        g.stroke({ color: 0xffffff, width: 1, alpha: 0.35 });
        g.x = x; g.y = y;

        // hover –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–∞
        g.eventMode = 'static';
        g.cursor = 'pointer';
        g.on('pointerover', () => g.tint = 0xff6666);
        g.on('pointerout',  () => g.tint = 0xffffff);

        app.stage.addChild(g);
      }

      // 4) –¢–µ–∫—Å—Ç (API Pixi v8)
      const label = new PIXI.Text({
        text: 'üß© Pixi v8 + Honeycomb: Hex OK',
        style: { fill: 0xffffff, fontSize: 18 }
      });
      label.x = 20; label.y = 95;
      app.stage.addChild(label);

      $msg('–ì–æ—Ç–æ–≤–æ: –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ + –≥–µ–∫—Å—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∏–¥–Ω—ã');
    } catch (e) {
      console.error(e);
      $msg('–û—à–∏–±–∫–∞ (—Å–º. Console): ' + e.message, true);
    }
  })();
  </script>
</body>
</html>
