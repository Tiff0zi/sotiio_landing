<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Hex Map</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { 
      margin:0; 
      height:100%; 
      overflow:hidden; 
      background:#1e1e1e; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }
    #msg { 
      position:fixed; 
      left:10px; 
      top:10px; 
      font:13px system-ui; 
      color:#e0e0e0; 
      background:#2c2c2c; 
      padding:6px 10px; 
      border-radius:8px; 
      border:1px solid #444;
    }
  </style>
</head>
<body>
  <div id="msg">Загрузка...</div>
  <script src="./PixiJS/pixi.min.js"></script>

  <script>
  (async () => {
    const M = (t, bad=false)=>{ 
      const el=document.getElementById('msg'); 
      el.textContent=t; 
      el.style.color=bad?'#ff4444':'#e0e0e0'; 
      console[bad?'error':'log'](t); 
    };

    if (!window.PIXI) { M('PIXI не найден', true); return; }
    
    const app = new PIXI.Application();
    await app.init({
      width: window.innerWidth,
      height: window.innerHeight,
      background: '#1e1e1e',
      antialias: true
    });
    document.body.appendChild(app.canvas);

    const container = new PIXI.Container();
    app.stage.addChild(container);

    // Центрируем карту
    container.x = app.screen.width / 2;
    container.y = app.screen.height / 2;

    // --- HEX математика ---
    const SQRT3 = Math.sqrt(3);
    const size = 42;
    
    const axialToPixel = (q, r) => ({
      x: size * (SQRT3 * q + SQRT3/2 * r),
      y: size * (1.5 * r)
    });

    // Функция для создания шестиугольника с закругленными углами
    const createRoundedHex = (radius, cornerRadius = 4) => {
      const points = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i - 30);
        points.push(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius
        );
      }
      return points;
    };

    const HEX_PTS = createRoundedHex(size, 4);

    // Создание шестиугольника
    const createHex = (q, r, labelText) => {
      const {x, y} = axialToPixel(q, r);

      // Основная графика для шестиугольника
      const graphics = new PIXI.Graphics();
      
      // Начальное состояние - только обводка
      graphics.poly(HEX_PTS, true)
              .fill(0x000000, 0) // Полностью прозрачная заливка
              .stroke({ color: 0xffffff, width: 1, alpha: 1 });
      
      graphics.x = x;
      graphics.y = y;
      graphics.eventMode = 'static';
      graphics.cursor = 'pointer';
      
      // Хит-область (без закругления для точности)
      const hitAreaPoints = createRoundedHex(size, 0);
      graphics.hitArea = new PIXI.Polygon(hitAreaPoints);
      
      container.addChild(graphics);

      // Метка
      const text = new PIXI.Text({
        text: labelText,
        style: {
          fill: 0xffffff,
          fontSize: 12,
          fontFamily: 'system-ui, Arial',
          fontWeight: '500'
        }
      });
      text.anchor.set(0.5);
      text.x = x;
      text.y = y;
      container.addChild(text);

      return { 
        graphics, 
        text, 
        q, 
        r,
        selected: false
      };
    };

    // --- Генерация карты ---
    const DIRS = [
      {q: +1, r: 0}, {q: +1, r: -1}, {q: 0, r: -1},
      {q: -1, r: 0}, {q: -1, r: +1}, {q: 0, r: +1}
    ];

    const HEXES = [];
    let selectedHex = null;

    // Центральная оранжевая сота
    const center = createHex(0, 0, 'Center');
    center.graphics.clear()
          .poly(HEX_PTS, true)
          .fill(0xff622b, 1) // Оранжевая заливка
          .stroke({ color: 0xffffff, width: 1, alpha: 1 });
    HEXES.push(center);

    // 6 направлений + лучи
    for (let i = 0; i < 6; i++) {
      const {q, r} = DIRS[i];
      
      // Основной узел направления
      const main = createHex(q, r, `R1-${i+1}`);
      HEXES.push(main);

      // Луч из 3 узлов
      for (let s = 1; s <= 3; s++) {
        const qq = q + s * DIRS[i].q;
        const rr = r + s * DIRS[i].r;
        const node = createHex(qq, rr, '');
        HEXES.push(node);
      }
    }

    // --- Взаимодействия ---
    const wireInteractions = (hexObj) => {
      hexObj.graphics.on('pointerover', () => {
        if (!hexObj.selected) {
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x000000, 0) // Прозрачная заливка
                .stroke({ color: 0x34a2db, width: 2, alpha: 1 }); // Синяя обводка при ховере
        }
      });

      hexObj.graphics.on('pointerout', () => {
        if (!hexObj.selected) {
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x000000, 0) // Прозрачная заливка
                .stroke({ color: 0xffffff, width: 1, alpha: 1 }); // Возвращаем белую обводку
        }
      });

      hexObj.graphics.on('pointertap', () => {
        // Снимаем выделение с предыдущей соты
        if (selectedHex && selectedHex !== hexObj) {
          selectedHex.selected = false;
          selectedHex.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x000000, 0)
                .stroke({ color: 0xffffff, width: 1, alpha: 1 });
        }

        // Если кликаем по уже выделенной - снимаем выделение
        if (hexObj.selected) {
          hexObj.selected = false;
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x000000, 0)
                .stroke({ color: 0xffffff, width: 1, alpha: 1 });
          selectedHex = null;
        } else {
          // Выделяем новую соту синим
          hexObj.selected = true;
          selectedHex = hexObj;
          hexObj.graphics.clear()
                .poly(HEX_PTS, true)
                .fill(0x34a2db, 1) // Синяя заливка
                .stroke({ color: 0xffffff, width: 2, alpha: 1 }); // Белая обводка
        }
      });
    };

    // Применяем взаимодействия ко всем сотам
    HEXES.forEach(hex => wireInteractions(hex));

    M('Готово: оранжевый центр, выделение синим, шестиугольники с закругленными углами');
  })();
  </script>
</body>
</html>
